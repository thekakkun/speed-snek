{"mappings":"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","sources":["src/scripts/geometry.ts","src/scripts/model.ts","src/scripts/graphics.ts","src/scripts/speedSnek.ts","src/scripts/main.ts"],"sourcesContent":["/** A single point defined by an x and y coordinate. */\nexport interface Point {\n  x: number;\n  y: number;\n}\n/** An arc, defined by a center point and radius. */\nexport interface Arc {\n  center: Point;\n  radius: number;\n}\n/** A list of Points. */\nexport type Path = Point[];\n\n/**\n * Calculate the distance between two points.\n * @param p1 The first point.\n * @param p2 The second point.\n * @returns The distance between the two points.\n */\nexport function dist(p1: Point, p2: Point): number {\n  return Math.sqrt((p1.x - p2.x) ** 2 + (p1.y - p2.y) ** 2);\n}\n\n/**\n *\n * @param seg1 A line segment, defined by two points.\n * @param arc An arc, defined by a center and radius.\n */\nexport function intersection(seg1: Path, arc: Arc): Point | null;\n/**\n *\n * @param seg1 A line segment, defined by two points.\n * @param seg2 A line segment, defined by two points.\n */\nexport function intersection(seg1: Path, seg2: Path): Point | null;\n/**\n *\n * @param seg1 A line segment.\n * @param seg2 A line segment or arc.\n * @returns the intersection coordinates between seg1 and seg2\n * or null if no intersection.\n */\nexport function intersection(seg1: Path, seg2: Arc | Path): Point | null {\n  if (\"center\" in seg2) {\n    const [{ x: x1, y: y1 }, { x: x2, y: y2 }] = seg1;\n    const {\n      center: { x: xc, y: yc },\n      radius,\n    } = seg2;\n\n    const a = (x1 - x2) ** 2 + (y1 - y2) ** 2;\n    const b = (x1 - x2) * (x2 - xc) + (y1 - y2) * (y2 - yc);\n    const c = (x2 - xc) ** 2 + (y2 - yc) ** 2 - radius ** 2;\n\n    /**\n     * discriminant > 0: 2 intersections\n     *\n     * discriminant = 0: 1 intersection\n     *\n     * discriminant < 0: 0 intersections\n     */\n    const discriminant = b ** 2 - a * c;\n    if (discriminant < 0) {\n      return null;\n    }\n\n    /**\n     * Parameter representing the line.\n     * Falls between the two points if 0 <= t <= 1.\n     */\n    let t: number;\n    t = (-b - Math.sqrt(discriminant)) / a;\n\n    // recalculate if current t places intersection outside of line segment.\n    if (!inRange(t)) {\n      t = (-b + Math.sqrt(discriminant)) / a;\n\n      if (!inRange(t)) {\n        // none of the possible values for t resulted in an intersection.\n        return null;\n      }\n    }\n\n    return {\n      x: t * x1 + (1 - t) * x2,\n      y: t * y1 + (1 - t) * y2,\n    };\n  } else {\n    const [{ x: x1, y: y1 }, { x: x2, y: y2 }] = seg1;\n    const [{ x: x3, y: y3 }, { x: x4, y: y4 }] = seg2;\n\n    /** If this is zero, line segments are parallel. */\n    const denominator = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);\n    if (Math.abs(denominator) < Number.EPSILON) {\n      return null;\n    }\n\n    /**\n     * Parameter representing the line through seg1.\n     * Falls between the two points of seg1 if  0 <= t <= 1.\n     */\n    const t = ((x1 - x3) * (y3 - y4) - (y1 - y3) * (x3 - x4)) / denominator;\n    if (!inRange(t, true)) {\n      return null;\n    }\n\n    /**\n     * Parameter representing the line through seg2.\n     * Falls between the two points of seg2 if  0 <= u <= 1.\n     */\n    const u = ((x1 - x3) * (y1 - y2) - (y1 - y3) * (x1 - x2)) / denominator;\n    if (!inRange(u, true)) {\n      return null;\n    }\n\n    return {\n      x: x1 + t * (x2 - x1),\n      y: y1 + t * (y2 - y1),\n    };\n  }\n}\n\n/**\n * Checks if parameter is within range,\n * with considerations for floating point error.\n * @param t parameter to test for.\n * @param coyote if true, exclude range boundary within floating point error.\n * @param range minimum and maximum acceptable value for t.\n * @returns whether t is between min and max.\n */\nfunction inRange(t: number, coyote = false, range?: [number, number]): boolean {\n  const [min, max] = range ?? [0, 1];\n  const tolerance = 1;\n  /** t is equal to range boundary within floating point error */\n  const boundary =\n    Math.abs(t - min) < tolerance * Number.EPSILON ||\n    Math.abs(t - max) < tolerance * Number.EPSILON;\n\n  if (boundary) {\n    return !coyote;\n  }\n  /** t is between min and max */\n  const within = min < t && t < max;\n  return within;\n}\n","import { dist, intersection, Path, Point } from \"./geometry\";\nimport { Canvas } from \"./graphics\";\n\n/**\n * Return a random number between min and max.\n * @param min Smallest value number can take (inclusive).\n * @param max Largest value number can take (exclusive).\n * @returns A random number between min and max.\n */\nfunction randomBetween(min: number, max: number) {\n  return Math.random() * (max - min) + min;\n}\n\n/**\n * Holds information about the user's pointer movement.\n */\nexport class Pointer {\n  canvas: Canvas;\n  path: Path;\n  timeStamp: DOMHighResTimeStamp[];\n  rawSpeed: number;\n  lastEvent: string;\n\n  /**\n   * Constructs a Pointer.\n   * @param canvas The canvas element capturing pointer info.\n   */\n  constructor(canvas: Canvas) {\n    this.canvas = canvas;\n    this.path = [];\n    this.timeStamp = [];\n    this.rawSpeed = 0;\n    this.lastEvent = \"\";\n    this.moveHandler = this.moveHandler.bind(this);\n  }\n\n  /**\n   * Handles incoming events and adds the data to Pointer.\n   * 'render' event is used to see if user has stopped moving,\n   * and will only update the path and timestamp data if\n   * no pointermove events coming.\n   * @param e The event, PointerEvent if triggered by 'pointermove'\n   * and Event if triggered by 'render'.\n   */\n  public moveHandler(e: PointerEvent | Event) {\n    if (e instanceof PointerEvent) {\n      const point = {\n        x: e.offsetX,\n        y: e.offsetY,\n      };\n\n      this.path.unshift(point);\n    } else if (this.lastEvent === e.type && this.path.length) {\n      this.path.unshift(this.path[0]);\n    }\n\n    this.timeStamp.unshift(e.timeStamp);\n    this.lastEvent = e.type;\n    this.setSpeed();\n  }\n\n  /**\n   * Trims unnecessary data in path and timeStamp.\n   * Meant to only leave enough to calculate the position of a newly added segment.\n   * @param ix The index of the last necessary point in path.\n   */\n  public trim(ix: number) {\n    this.path.splice(ix);\n    this.timeStamp.splice(ix);\n  }\n\n  /**\n   * Calculates the speed based off of path and timeStamp,\n   * Set window value to use a moving average.\n   * @param window The number of data points to average over.\n   */\n  public setSpeed(window = 1) {\n    window = Math.min(window, this.path.length - 1);\n\n    let travelled = 0;\n    let time = 0;\n    for (let i = 0; i < window; i++) {\n      travelled += dist(this.path[i], this.path[i + 1]);\n      time += this.timeStamp[i] - this.timeStamp[i + 1];\n    }\n\n    if (travelled === 0 || time === 0) {\n      this.rawSpeed = 0;\n    } else {\n      this.rawSpeed = travelled / time;\n    }\n  }\n}\n\n/**\n * Holds information about the Snek.\n * @extends Pointer\n */\nexport class Snek extends Pointer {\n  segments: number;\n  segLength: number;\n  segmentPath: Path;\n  snekWidth: number;\n  speed: number;\n\n  /**\n   * Constructs a Snek.\n   * @param canvas The canvas element capturing pointer info.\n   */\n  constructor(canvas: Canvas) {\n    super(canvas);\n\n    this.segments = 4;\n    this.segLength = 50;\n    this.snekWidth = 10;\n    this.speed = 0;\n    this.segmentPath = [\n      {\n        x: this.canvas.width / 2,\n        y: this.canvas.height / 2,\n      },\n    ];\n    for (let i = 0; i < this.segments; i++) {\n      const nextSeg = {\n        x: this.segmentPath[i].x,\n        y: this.segmentPath[i].y + this.segLength,\n      };\n\n      this.segmentPath.push(nextSeg);\n      this.path.push(nextSeg);\n      this.timeStamp.push(0);\n    }\n  }\n\n  /**\n   * Handles incoming events and updates Snek properties.\n   * @param e The event, PointerEvent if triggered by 'pointermove'\n   * and Event if triggered by 'render'.\n   */\n  public moveHandler(e: PointerEvent | Event) {\n    super.moveHandler(e);\n    this.calculateSegments();\n    this.setSpeed();\n  }\n\n  /** Calculate the position of the segments, based on path. */\n  public calculateSegments() {\n    Object.assign(this.segmentPath, this.path, { length: 1 });\n    let segHead = this.segmentPath[this.segmentPath.length - 1];\n    for (let [ix, p] of this.path.entries()) {\n      if (this.segmentPath.length <= this.segments) {\n        while (this.segLength < dist(segHead, p)) {\n          const seg = [this.path[ix - 1], p];\n          const arc = {\n            center: segHead,\n            radius: this.segLength,\n          };\n          segHead = intersection(seg, arc) as Point;\n\n          this.segmentPath.push(segHead);\n          if (this.segments < this.segmentPath.length) {\n            break;\n          }\n        }\n      } else {\n        if (this.segLength * 2 <= dist(segHead, p)) {\n          super.trim(ix);\n        }\n      }\n    }\n  }\n\n  /** Calculate a smoothed speed, based on the raw value.\n   * Smoothing is done via exponential smoothing.\n   */\n  public setSpeed(window = 1) {\n    window = Math.min(window, this.path.length - 1);\n    super.setSpeed(window);\n\n    /**\n     * The time constant.\n     * The time it takes a unit step function to reach\n     * 63.2^ of the original signal.\n     * */\n    const tau = 0.5;\n    const tDelta = (this.timeStamp[0] - this.timeStamp[window]) / 1000 / window;\n    const alpha = 1 - Math.exp(-tDelta / tau);\n\n    this.speed = alpha * this.rawSpeed + (1 - alpha) * this.speed;\n  }\n\n  public grow() {\n    this.segments += 1;\n  }\n}\n\n/**\n * Holds information about the Pellet.\n */\nexport class Pellet {\n  canvas: Canvas;\n  loc: Point;\n  radius: number;\n\n  /**\n   * Construct a Pellet.\n   * @param canvas The Canvas object where pellet is placed.\n   */\n  constructor(canvas: Canvas) {\n    this.radius = 15;\n    this.canvas = canvas;\n    this.loc = Object.create({});\n  }\n\n  /**\n   * Choose a location to place the pellet within the canvas.\n   * Must not be within buffer range from canvas borders or noGo path.\n   * @param noGo Path where no pellet can be placed within buffer range.\n   * @param buffer The size of the buffer.\n   */\n  place(noGo?: Path, buffer = 30) {\n    let loc: Point;\n    let locValid: boolean;\n\n    while (true) {\n      locValid = true;\n      loc = {\n        x: randomBetween(buffer, this.canvas.width - buffer),\n        y: randomBetween(buffer, this.canvas.height - buffer),\n      };\n\n      // loc is fine if there is no noGo\n      if (noGo === undefined) {\n        this.loc = loc;\n        break;\n      }\n\n      // Check if loc within buffer distance of noGo path.\n      for (let i = 0; i < noGo.length - 1; i++) {\n        if (\n          intersection([noGo[i], noGo[i + 1]], {\n            center: loc,\n            radius: this.radius + buffer,\n          })\n        ) {\n          // loc is too close to noGo, try again.\n          locValid = false;\n          break;\n        }\n      }\n\n      if (locValid) {\n        Object.assign(this.loc, loc);\n        break;\n      }\n    }\n  }\n}\n","import { Arc, Path, Point } from \"./geometry\";\nimport { SpeedSnek } from \"./speedSnek\";\n\n// TODO: Can I share these variables with SASS?\nexport const white = \"#fdfffc\";\nexport const red = \"#ff3333\";\nexport const green = \"#94e34f\";\nexport const blue = \"#49b9e6\";\nexport const background = \"#040406\";\n\n/**\n * Calculate the game canvas size and orientation, based on available space.\n * @returns The width and height of the game canvas.\n */\nexport function gameSize(): [number, number] {\n  let width: number;\n  let height: number;\n\n  const ratio = 1.5;\n  const maxSide = 600;\n  const borderWidth = parseInt(\n    getComputedStyle(document.getElementById(\"game\") as HTMLElement).borderWidth\n  );\n\n  const dispHeight = document.documentElement.clientHeight;\n  const dispWidth = document.documentElement.clientWidth;\n\n  const uiHeight = document.getElementById(\"ui\")?.clientHeight as number;\n\n  if ((dispHeight - uiHeight) / dispWidth < 1) {\n    height = Math.min(maxSide, dispHeight - uiHeight - borderWidth * 2);\n    width = height * ratio;\n  } else {\n    width = Math.min(maxSide, dispWidth - borderWidth * 2);\n    height = width * ratio;\n  }\n\n  return [width, height];\n}\n\n/** Class representing the canvas object. */\nexport class Canvas {\n  height: number;\n  width: number;\n  element: HTMLCanvasElement;\n  context: CanvasRenderingContext2D;\n\n  /**\n   * Create a Canvas.\n   * @param id The id of the canvas.\n   * @param width Width of the canvas, pulled from calcualted width if omitted.\n   * @param height Width of the canvas, pulled from calcualted width if omitted.\n   */\n  constructor(id: string, width?: number, height?: number) {\n    this.element = document.getElementById(id) as HTMLCanvasElement;\n    this.context = this.element.getContext(\"2d\") as CanvasRenderingContext2D;\n\n    if (width === undefined) {\n      width = this.element.clientWidth;\n    }\n    if (height === undefined) {\n      height = this.element.clientHeight;\n    }\n\n    this.width = width;\n    this.height = height;\n\n    this.setSize();\n  }\n\n  /**\n   * Scales the canvas so that there is no blurring for high density displays.\n   */\n  setSize() {\n    this.element.style.width = `${this.width}px`;\n    this.element.style.height = `${this.height}px`;\n\n    this.element.width = Math.floor(this.width * devicePixelRatio);\n    this.element.height = Math.floor(this.height * devicePixelRatio);\n\n    this.context.scale(devicePixelRatio, devicePixelRatio);\n  }\n\n  /** wipe the canvas clean. */\n  clear() {\n    this.context.clearRect(0, 0, this.width, this.height);\n  }\n}\n\n/** Defines the need for a render() method for\n * both complex and simple Components. */\nabstract class Component {\n  protected parent!: Component | null;\n\n  /**\n   * Set the parent Component.\n   * @param parent The parent Component.\n   */\n  public setParent(parent: Component | null) {\n    this.parent = parent;\n  }\n\n  /**\n   * Get the parent Component.\n   * @returns The parent Component or null if no parent.\n   */\n  public getParent(): Component | null {\n    return this.parent;\n  }\n\n  public abstract render(): void;\n}\n\n/**\n * Composite objects represent complex Components with children.\n * Calling render() will delegate actual work to its children.\n * @extends Component\n */\nexport class Composite extends Component {\n  protected children: Component[] = [];\n\n  /**\n   * Adds a child component.\n   * @param component The child component to add to Compsite.\n   */\n  public add(component: Component) {\n    this.children.push(component);\n    component.setParent(this);\n  }\n\n  /**\n   * Removes a child component.\n   * @param component The child component to remove from Composite.\n   */\n  public remove(component: Component) {\n    const ix = this.children.indexOf(component);\n    this.children.splice(ix, 1);\n\n    component.setParent(null);\n  }\n\n  /** Delegate render() method to its children. */\n  public render() {\n    for (const child of this.children) {\n      child.render();\n    }\n  }\n}\n\n/**\n * A Component with parameters defining the data source and output target\n * @extends Component\n */\nabstract class GraphicsComponent<Type> extends Component {\n  public data: Type;\n  public canvas: Canvas;\n\n  /**\n   * Create a GraphicsComponent\n   * @param data The data source.\n   * @param canvas Canvas to render data on.\n   */\n  constructor(data: Type, canvas: Canvas) {\n    super();\n    this.data = data;\n    this.canvas = canvas;\n  }\n}\n\n/**\n * Used to draw a line on the canvas.\n * @extends GraphicsComponent\n */\nexport class CanvasLine extends GraphicsComponent<Path> {\n  color: string;\n  width: number;\n\n  /**\n   * Constructs a CanvasLine\n   * @param data A list of coordinates for the line.\n   * @param canvas The Canvas to render to.\n   * @param color The color of the line.\n   * @param width The width of the line.\n   */\n  constructor(data: Path, canvas: Canvas, color: string, width: number) {\n    super(data, canvas);\n    this.color = color;\n    this.width = width;\n  }\n\n  /** Draw a line on the canvas. */\n  render() {\n    const path = this.data;\n    const ctx = this.canvas.context;\n\n    if (path.length !== 0) {\n      ctx.strokeStyle = this.color;\n      ctx.lineWidth = this.width;\n      ctx.lineCap = \"round\";\n      ctx.lineJoin = \"round\";\n      ctx.beginPath();\n      ctx.moveTo(path[0].x, path[0].y);\n      path.forEach((point: Point) => {\n        ctx.lineTo(point.x, point.y);\n      });\n      ctx.stroke();\n    }\n  }\n}\n\n/**\n * Used to draw a circle (unfilled) on the canvas.\n * @extends GraphicsComponent\n */\nexport class CanvasCircle extends GraphicsComponent<Arc> {\n  color: string;\n  width: number;\n\n  /**\n   * Constructs a CanvasCircle.\n   * @param data The center and radius of the circle\n   * @param canvas The Canvas to render to.\n   * @param color The color of the circle.\n   * @param width The width of the line.\n   */\n  constructor(data: Arc, canvas: Canvas, color: string, width: number) {\n    super(data, canvas);\n    this.color = color;\n    this.width = width;\n  }\n\n  /** Draw a circle on the canvas. */\n  render() {\n    const ctx = this.canvas.context;\n    ctx.beginPath();\n    ctx.strokeStyle = this.color;\n    ctx.lineWidth = this.width;\n    ctx.arc(\n      this.data.center.x,\n      this.data.center.y,\n      this.data.radius,\n      0,\n      Math.PI * 2\n    );\n    ctx.stroke();\n  }\n}\n\n/**\n * Used to draw a disc (filled) on the canvas.\n * @extends GraphicsComponent\n */\nexport class CanvasDisc extends GraphicsComponent<Arc> {\n  color: string;\n\n  /**\n   * Constructs a CanvasDisc\n   * @param data The center and radius of the circle\n   * @param canvas The Canvas to render to.\n   * @param color The color of the circle.\n   */\n  constructor(data: Arc, canvas: Canvas, color: string) {\n    super(data, canvas);\n    this.color = color;\n  }\n\n  /** Draw a disc on the canvas. */\n  render() {\n    if (this.data.center) {\n      const ctx = this.canvas.context;\n      ctx.fillStyle = this.color;\n      ctx.beginPath();\n      ctx.arc(\n        this.data.center.x,\n        this.data.center.y,\n        this.data.radius,\n        0,\n        Math.PI * 2\n      );\n      ctx.fill();\n    }\n  }\n}\n\n/**\n * Used to draw the speedometer.\n * @extends GraphicsComponent\n */\nexport class SpeedGraphics extends GraphicsComponent<SpeedSnek> {\n  barWidth: number;\n  margin: number;\n  border: number;\n  barCount: number;\n\n  /**\n   * Construct a SpeedGraphics.\n   * @param data contains various pieces of data regarding speed.\n   * @param canvas The Canvas to render to.\n   */\n  constructor(data: SpeedSnek, canvas: Canvas) {\n    super(data, canvas);\n\n    this.barWidth = 6;\n    this.margin = 3;\n    this.border = parseInt(getComputedStyle(canvas.element).borderWidth);\n    this.barCount = Math.floor(\n      (canvas.width - this.border) / (this.barWidth + this.margin)\n    );\n  }\n\n  /** Draw the speedometer */\n  render() {\n    const speedLimitPercent = this.data.speedLimit / this.data.maxSpeed;\n    const speedPercent = this.data.snek.speed / this.data.maxSpeed;\n\n    const ctx = this.canvas.context;\n    let color: typeof red | typeof white | typeof background;\n\n    for (let i = 0; i <= this.barCount; i++) {\n      const colorBoundary =\n        (this.border + (this.barWidth + this.margin) * i - this.margin) /\n        (this.canvas.width - this.border * 2);\n\n      if (colorBoundary < speedLimitPercent) {\n        color = red;\n      } else if (colorBoundary < speedPercent) {\n        color = white;\n      } else {\n        color = background;\n      }\n\n      ctx.strokeStyle = color;\n      ctx.lineWidth = this.barWidth;\n      ctx.lineCap = \"round\";\n      ctx.lineJoin = \"round\";\n      ctx.beginPath();\n      ctx.moveTo(\n        (this.barWidth + this.margin) * i + this.barWidth / 2,\n        this.barWidth / 2\n      );\n      ctx.lineTo(\n        (this.barWidth + this.margin) * i + this.barWidth / 2,\n        this.canvas.height - this.barWidth / 2\n      );\n      ctx.stroke();\n    }\n  }\n}\n","import { Arc, dist, intersection } from \"./geometry\";\nimport { Pellet, Snek } from \"./model\";\nimport {\n  blue,\n  Canvas,\n  CanvasCircle,\n  CanvasDisc,\n  CanvasLine,\n  Composite,\n  SpeedGraphics,\n  gameSize,\n  green,\n  red,\n} from \"./graphics\";\n\n/**\n * The main game object. Responsible for game metadata\n * and for running the logic update and rendering loop,\n * which change depending on the game state.\n */\nexport class SpeedSnek {\n  private state: State;\n\n  public score: number;\n  public bestScore: number;\n  public speedLimit: number;\n  public speedIncrement: number;\n  public maxSpeed: number;\n\n  public speedCanvas: Canvas;\n  public gameCanvas: Canvas;\n  public reqId: number;\n  public inputType: \"mouse\" | \"touch\";\n\n  /** The Snek object. */\n  public snek: Snek;\n  public pellet: Pellet;\n\n  /**\n   * Constructs a SpeedSnek.\n   */\n  constructor() {\n    this.gameLoop = this.gameLoop.bind(this);\n\n    // initialize canvas\n    this.gameCanvas = new Canvas(\"gameBoard\", ...gameSize());\n    const uiElement = document.getElementById(\"ui\") as HTMLElement;\n    uiElement.style.width = `${this.gameCanvas.width}px`;\n    this.speedCanvas = new Canvas(\n      \"speedometer\",\n      undefined,\n      document.getElementById(\"score\")?.clientHeight ?? 60\n    );\n    this.inputType = \"mouse\";\n  }\n\n  /**\n   * Runs the exit() method for the current state (if it exists),\n   * then transitions to a new state and runs its enter() method.\n   * @param state State to transition to.\n   */\n  public transitionTo(state: State): void {\n    if (this.state) {\n      this.state.exit();\n    }\n\n    if (process.env.NODE_ENV === \"development\") {\n      console.log(`Context: Transition to ${(<any>state).constructor.name}.`);\n    }\n\n    this.state = state;\n    this.state.setContext(this);\n    this.state.enter();\n  }\n\n  /** Start a new game */\n  public newGame() {\n    // initialize game state\n    this.score = 0;\n    const bestScore = localStorage.getItem(\"bestScore\");\n    this.bestScore = bestScore ? Number(bestScore) : 0;\n    this.speedLimit = 0;\n    this.speedIncrement = 0.05;\n    this.maxSpeed = 5;\n    this.showScore()\n\n    // initialize game objects\n    this.snek = new Snek(this.gameCanvas);\n    this.pellet = new Pellet(this.gameCanvas);\n\n    // display the title screen\n    this.transitionTo(new Title());\n  }\n\n  /**\n   * Called when a pellet is eaten.\n   * Updates the score and speed limit\n   */\n  public increaseScore() {\n    this.score += 1;\n    this.bestScore = Math.max(this.bestScore, this.score);\n    this.speedLimit = Math.min(\n      this.speedLimit + this.speedIncrement,\n      this.maxSpeed\n    );\n    this.snek.grow();\n  }\n\n  /** The main game loop. update() checks for logic,\n   * render() draws canvas graphics. */\n  public gameLoop() {\n    this.update();\n    this.render();\n    this.reqId = requestAnimationFrame(this.gameLoop);\n  }\n\n  /** Shows the current and best scores. */\n  public showScore(): void {\n    const currentScore = document.getElementById(\"currentScore\") as HTMLElement;\n    currentScore.innerHTML = `Score: ${String(this.score).padStart(2, \"\\xa0\")}`;\n\n    const bestScore = document.getElementById(\"bestScore\") as HTMLElement;\n    bestScore.innerHTML = `Best: ${String(this.bestScore).padStart(2, \"\\xa0\")}`;\n  }\n\n  /** Dispatches the update method to state. */\n  public update(): void {\n    this.state.update();\n  }\n\n  /**\n   * Clears the canvases, then dispaches render method to state\n   * to render a new frame.\n   *\n   * Also responsible for showing game score and triggering the render event.\n   */\n  public render(): void {\n    this.gameCanvas.clear();\n    this.speedCanvas.clear();\n    this.showScore();\n    this.state.graphics.render();\n    dispatchEvent(new Event(\"render\"));\n  }\n}\n\n/**\n * The abstract State class, declares properties and methods all\n * States should implement.\n */\nabstract class State {\n  public game: SpeedSnek;\n  public graphics: Composite;\n\n  messageElement: HTMLElement;\n\n  /**\n   * Constructs a State.\n   * @param graphics A composite object wrapping all Canvas render methods.\n   */\n  constructor(graphics = new Composite()) {\n    this.graphics = graphics;\n    this.messageElement = document.getElementById(\"message\") as HTMLElement;\n  }\n\n  /** Sets a backreference to the SpeedSnek object. */\n  public setContext(game: SpeedSnek) {\n    this.game = game;\n  }\n\n  /** Runs when transitioning to State. */\n  public abstract enter(): void;\n  /** Logic checking, triggered by the game loop. */\n  public update(): void {}\n  /** Runs when transitioning from State. */\n  public abstract exit(): void;\n}\n\n/**\n * State: Displaying game instructions, listening to click on\n * start button.\n * @extends State\n */\nclass Title extends State {\n  /** Construct a Title State. */\n  constructor() {\n    super();\n  }\n\n  /** On entering Title state, show instructions and\n   * await start button click. */\n  public enter(): void {\n    const info = document.getElementById(\"info\") as HTMLElement;\n    info.style.display = \"flex\";\n    const startMessage = document.getElementById(\"startMessage\") as HTMLElement;\n    startMessage.style.display = \"block\";\n    const endMessage = document.getElementById(\"endMessage\") as HTMLElement;\n    endMessage.style.display = \"none\";\n\n    const startButton = document.getElementById(\n      \"startButton\"\n    ) as HTMLButtonElement;\n\n    startButton.addEventListener(\n      \"click\",\n      () => {\n        this.game.transitionTo(new Ready());\n      },\n      { once: true }\n    );\n    startButton.addEventListener(\n      \"pointerup\",\n      (e) => {\n        if (e.pointerType === \"touch\") {\n          this.game.inputType = e.pointerType;\n        }\n      },\n      { once: true }\n    );\n  }\n\n  /** Hide instruction elements on transition away from Title. */\n  public exit(): void {\n    const info = document.getElementById(\"info\") as HTMLElement;\n    info.style.display = \"none\";\n  }\n}\n\n/**\n * State: UI and snek are rendered, ready for user input.\n * @extends State\n */\nclass Ready extends State {\n  /** Transition to next state if user pointer within this area */\n  readyArea!: Arc;\n  readyAreaGraphics!: CanvasCircle;\n\n  /** Constructs a Ready State. */\n  constructor() {\n    super();\n    this.checkPlayerReady = this.checkPlayerReady.bind(this);\n  }\n\n  /**\n   * On transitioning to state, initialize game graphics,\n   * and await user input.\n   */\n  public enter(): void {\n    const pointerType = this.game.inputType === \"mouse\" ? \"cursor\" : \"finger\";\n    this.messageElement.innerText = `${pointerType} on the circle to start`;\n    this.initSpeedGraphics();\n    this.initGameGraphics();\n\n    const gameElement = this.game.gameCanvas.element;\n    gameElement.addEventListener(\"pointerdown\", (e) => {\n      gameElement.releasePointerCapture(e.pointerId);\n    });\n    gameElement.addEventListener(\"pointermove\", this.checkPlayerReady);\n    this.game.reqId = requestAnimationFrame(this.game.gameLoop);\n  }\n\n  /** Initialize the speedometer graphics Composite. */\n  initSpeedGraphics() {\n    const speedGraphics = new SpeedGraphics(this.game, this.game.speedCanvas);\n    this.graphics.add(speedGraphics);\n  }\n\n  /** Initialize the game graphics Composite. */\n  initGameGraphics() {\n    const snek = this.game.snek;\n    const gameGraphics = new Composite();\n\n    if (process.env.NODE_ENV === \"development\") {\n      /** Raw input from cursor, only shown during dev */\n      const cursorLine = new CanvasLine(\n        snek.path,\n        this.game.gameCanvas,\n        red,\n        1\n      );\n      gameGraphics.add(cursorLine);\n    }\n    const snekLine = new CanvasLine(\n      snek.segmentPath,\n      this.game.gameCanvas,\n      green,\n      snek.snekWidth\n    );\n    gameGraphics.add(snekLine);\n    this.graphics.add(gameGraphics);\n\n    this.readyArea = {\n      center: {\n        x: this.game.gameCanvas.width / 2,\n        y: this.game.gameCanvas.height / 2,\n      },\n      radius: 30,\n    };\n    this.readyAreaGraphics = new CanvasCircle(\n      this.readyArea,\n      this.game.gameCanvas,\n      red,\n      5\n    );\n    this.graphics.add(this.readyAreaGraphics);\n  }\n\n  /**\n   * Transition to Set state once pointer is within readyArea.\n   * @param e The PointerEvent from the listener.\n   */\n  checkPlayerReady(e: PointerEvent) {\n    const gameCanvas = this.game.gameCanvas;\n    const gameWrapper = gameCanvas.element.parentElement as HTMLElement;\n\n    const cursor = {\n      x: e.x - gameWrapper.offsetLeft - gameWrapper.clientLeft,\n      y: e.y - gameWrapper.offsetTop - gameWrapper.clientTop,\n    };\n\n    if (dist(cursor, this.readyArea.center) < this.readyArea.radius) {\n      this.game.transitionTo(new Set(this.graphics));\n    }\n  }\n\n  /** Remove readyArea on transition from Ready State. */\n  public exit(): void {\n    this.game.gameCanvas.element.removeEventListener(\n      \"pointermove\",\n      this.checkPlayerReady\n    );\n    this.graphics.remove(this.readyAreaGraphics);\n  }\n}\n\n/**\n * State: Speedometer and snek are responding to user input, showing countdown.\n * @extends State\n */\nclass Set extends State {\n  startTime: number;\n\n  /** Constructs a Set State. */\n  constructor(graphics: Composite) {\n    super(graphics);\n    this.startTime = Date.now();\n    this.notReady = this.notReady.bind(this);\n  }\n\n  /**\n   * Add eventListeners for game interaction.\n   * Check that user hasn't stopped interacting with game canvas.\n   */\n  public enter(): void {\n    const gameElement = this.game.gameCanvas.element;\n    gameElement.addEventListener(\"pointermove\", this.game.snek.moveHandler);\n    addEventListener(\"render\", this.game.snek.moveHandler);\n    gameElement.addEventListener(\"pointerleave\", this.notReady, {\n      once: true,\n    });\n  }\n\n  /** Start the countdown to transition to next State. */\n  update() {\n    const countStart = 3;\n    const elapsed = (Date.now() - this.startTime) / 1000;\n\n    this.messageElement.innerText = String(countStart - Math.floor(elapsed));\n\n    if (countStart < elapsed) {\n      this.game.transitionTo(new Go(this.graphics));\n    }\n  }\n\n  /** Go back to Ready state. */\n  notReady() {\n    removeEventListener(\"render\", this.game.snek.moveHandler);\n    this.game.transitionTo(new Ready());\n  }\n\n  /** On transition from state, remove triggering notReady(). */\n  public exit(): void {\n    this.game.gameCanvas.element.removeEventListener(\n      \"pointerleave\",\n      this.notReady\n    );\n  }\n}\n\n/**\n * State: The player is now playing the game\n * @extends State\n */\nclass Go extends State {\n  /** Constructs a Go State. */\n  constructor(graphics: Composite) {\n    super(graphics);\n    this.snekLeave = this.snekLeave.bind(this);\n  }\n\n  /** On transition to Go state, place the pellet in the canvas. */\n  public enter(): void {\n    this.game.gameCanvas.element.addEventListener(\n      \"pointerleave\",\n      this.snekLeave\n    );\n\n    this.messageElement.innerHTML = \"GO!\";\n    setTimeout(() => {\n      this.messageElement.innerText = \"\";\n    }, 1000);\n\n    const pellet = this.game.pellet;\n    const snek = this.game.snek;\n    pellet.place(snek.segmentPath);\n\n    this.graphics.add(\n      new CanvasDisc(\n        { center: this.game.pellet.loc!, radius: this.game.pellet.radius },\n        this.game.gameCanvas,\n        blue\n      )\n    );\n  }\n\n  /** Check for scoring and game over. */\n  update() {\n    this.speedCheck();\n    this.snekPelletCollision();\n    this.snekSnekCollision();\n    if (process.env.NODE_ENV === \"development\") {\n      this.messageElement.innerText = String(\n        this.game.snek.speed.toPrecision(3)\n      );\n    }\n  }\n\n  /** Transition to GameOver if under speed limit. */\n  speedCheck() {\n    if (this.game.snek.speed < this.game.speedLimit) {\n      console.log(\"faster!\");\n      this.game.transitionTo(new GameOver(\"You were too slow!\"));\n    }\n  }\n\n  /** Check for snek eating pellet. */\n  snekPelletCollision() {\n    if (this.game.pellet.loc) {\n      if (\n        2 <= this.game.snek.path.length &&\n        intersection([this.game.snek.path[0], this.game.snek.path[1]], {\n          center: this.game.pellet.loc,\n          radius: this.game.pellet.radius + this.game.snek.snekWidth / 2,\n        })\n      ) {\n        console.log(\"nom!\");\n        this.game.increaseScore();\n        this.game.pellet.place(this.game.snek.segmentPath);\n      }\n    }\n  }\n\n  /** Trigger if snek has left the game canvas. */\n  snekLeave() {\n    console.log(\"whoops!\");\n    this.game.transitionTo(new GameOver(\"You crashed into a wall!\"));\n  }\n\n  /** Check for snek colliding with itself. */\n  snekSnekCollision() {\n    for (let i = 2; i < this.game.snek.segmentPath.length - 1; i++) {\n      if (\n        intersection(\n          [this.game.snek.segmentPath[0], this.game.snek.segmentPath[1]],\n          [this.game.snek.segmentPath[i], this.game.snek.segmentPath[i + 1]]\n        )\n      ) {\n        console.log(\"ouch!\");\n        this.game.transitionTo(new GameOver(\"You crashed into yourself!\"));\n      }\n    }\n  }\n\n  /** Remove gameplay event listeners on transition to next State. */\n  public exit(): void {\n    const gameElement = this.game.gameCanvas.element;\n    gameElement.removeEventListener(\"pointerleave\", this.snekLeave);\n    gameElement.removeEventListener(\"pointermove\", this.game.snek.moveHandler);\n    removeEventListener(\"render\", this.game.snek.moveHandler);\n  }\n}\n\n/**\n * State: Snek is dead ;(.\n * @extends State\n */\nclass GameOver extends State {\n  reason: string;\n\n  /**\n   * Constructs a GameOver State.\n   * @param reason Reason for game over.\n   */\n  constructor(reason: string) {\n    super();\n    this.reason = reason;\n  }\n\n  /**\n   * On transitioning to GameOver, display the info elements,\n   * with information on the last game, and a button to play again.\n   */\n  public enter(): void {\n    localStorage.setItem(\"bestScore\", String(this.game.bestScore));\n\n    const reasonElement = document.getElementById(\"reason\") as HTMLElement;\n    reasonElement.innerText = this.reason;\n\n    const scoreElement = document.getElementById(\"finalScore\") as HTMLElement;\n    scoreElement.innerText = `Score: ${this.game.score}`;\n\n    const bestElement = document.getElementById(\"best\") as HTMLElement;\n    bestElement.innerText =\n      `Best: ${this.game.bestScore}` +\n      (this.game.score === this.game.bestScore ? \" (NEW BEST!)\" : \"\");\n\n    const info = document.getElementById(\"info\") as HTMLElement;\n    info.style.display = \"flex\";\n\n    const startMessage = document.getElementById(\"startMessage\") as HTMLElement;\n    startMessage.style.display = \"none\";\n    const endMessage = document.getElementById(\"endMessage\") as HTMLElement;\n    endMessage.style.display = \"block\";\n\n    const restartButton = document.getElementById(\n      \"restartButton\"\n    ) as HTMLButtonElement;\n\n    restartButton.addEventListener(\n      \"click\",\n      () => {\n        this.game.newGame();\n      },\n      { once: true }\n    );\n  }\n\n  public exit(): void {\n    cancelAnimationFrame(this.game.reqId);\n  }\n}\n","import { SpeedSnek } from \"./speedSnek\";\n\naddEventListener(\"load\", () => {\n  const speedSnek = new SpeedSnek();\n  speedSnek.newGame();\n\n  console.log(`\\\n==================\n\nüêç says,\n  üíΩ See my source code here!\n      https://github.com/thekakkun/speed-snek\n  üí∏ Like what you see? Donate!\n      https://ko-fi.com/kakkun\n\n==================\\\n  `);\n});\n"],"names":["$512903f9dc58181d$export$6c4a311cc157c764","p1","p2","Math","sqrt","x","y","$512903f9dc58181d$export$bc86dfbf7795668c","seg1","seg2","x1","y1","x2","y2","center","xc","yc","radius","a","b","discriminant","t","$512903f9dc58181d$var$inRange","x11","y11","x21","y21","x3","y3","x4","y4","denominator","abs","Number","EPSILON","t1","coyote","range","min","max","$de1c67ad03edf268$var$randomBetween","random","$de1c67ad03edf268$export$5d379a99196b5d4e","constructor","canvas","this","path","timeStamp","rawSpeed","lastEvent","moveHandler","bind","e","PointerEvent","point","offsetX","offsetY","unshift","type","length","setSpeed","trim","ix","splice","window","travelled","time","i","super","segments","segLength","snekWidth","speed","segmentPath","width","height","nextSeg","push","calculateSegments","Object","assign","segHead","p","entries","tDelta","alpha","exp","grow","$de1c67ad03edf268$export$8d468b1b2457c918","loc","create","place","noGo","buffer","locValid","undefined","$11f96767ac22f166$export$e5d96c10a4f7ae2f","borderWidth","parseInt","getComputedStyle","document","getElementById","dispHeight","documentElement","clientHeight","dispWidth","clientWidth","uiHeight","$11f96767ac22f166$export$8d01c972ee8b14a9","id","element","context","getContext","setSize","style","floor","devicePixelRatio","scale","clear","clearRect","$11f96767ac22f166$var$Component","setParent","parent","getParent","$11f96767ac22f166$export$43586241d9db0c6d","children","add","component","remove","indexOf","render","child","$11f96767ac22f166$var$GraphicsComponent","data","$11f96767ac22f166$export$12929c049f38ef60","color","ctx","strokeStyle","lineWidth","lineCap","lineJoin","beginPath","moveTo","forEach","lineTo","stroke","$11f96767ac22f166$export$c286ce9e59146edc","arc","PI","$11f96767ac22f166$export$56d6048a90046ca9","fillStyle","fill","$11f96767ac22f166$export$472c2da4f0ac63e5","barWidth","margin","border","barCount","speedLimitPercent","speedLimit","maxSpeed","speedPercent","snek","colorBoundary","$8afd2f20f372f024$export$201ff456803fd722","gameLoop","gameCanvas","speedCanvas","inputType","transitionTo","state","exit","setContext","enter","newGame","score","bestScore","localStorage","getItem","speedIncrement","showScore","pellet","$8afd2f20f372f024$var$Title","increaseScore","update","reqId","requestAnimationFrame","innerHTML","String","padStart","graphics","dispatchEvent","Event","$8afd2f20f372f024$var$State","messageElement","game","display","startButton","addEventListener","$8afd2f20f372f024$var$Ready","once","pointerType","checkPlayerReady","innerText","initSpeedGraphics","initGameGraphics","gameElement","releasePointerCapture","pointerId","speedGraphics","gameGraphics","snekLine","readyArea","readyAreaGraphics","gameWrapper","parentElement","offsetLeft","clientLeft","offsetTop","clientTop","$8afd2f20f372f024$var$Set","removeEventListener","startTime","Date","now","notReady","elapsed","$8afd2f20f372f024$var$Go","snekLeave","setTimeout","speedCheck","snekPelletCollision","snekSnekCollision","console","log","$8afd2f20f372f024$var$GameOver","reason","setItem","cancelAnimationFrame"],"version":3,"file":"index.8f5f71d6.js.map"}